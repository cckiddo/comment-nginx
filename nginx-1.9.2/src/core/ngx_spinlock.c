
/*
 * Copyright (C) Igor Sysoev
 * Copyright (C) Nginx, Inc.
 */


#include <ngx_config.h>
#include <ngx_core.h>

/*
基于原子操作，Nginx实现了一个自旋锁。自旋锁是一种非睡眠锁，也就是说，某进程如果试图获得自旋锁，当发现锁已经被其他进程获得时，
那么不会使得当前进程进入睡眠状态，而是始终保持进程在可执行状态，每当内核调度到这个进程执行时就持续检查是否可以获取到锁。在拿
不到锁时，这个进程的代码将会一直在自旋锁代码处执行，直到其他进程释放了锁且当前进程获取到了锁后，代码才会继续向下执行。

可见，自旋锁主要是为多处理器操作系统而设置的，它要解决的共享资源保护场景就是进程使用锁的时间非常短（如果锁的使用时间很久，
自旋锁会不太合适，那么它会占用大量的CPU资源）

    事实上，自旋锁的初衷就是：在短期间内进行轻量级的锁定。一个被争用的自旋锁使得请求它的线程在等待锁重新可用的期间进行自旋(特别浪费
处理器时间)，所以自旋锁不应该被持有时间过长。如果需要长时间锁定的话, 最好使用信号量。

自旋锁实际上是忙等锁
    当锁不可用时，CPU一直循环执行“测试并设置”该锁直到可用而取得该锁，CPU在等待自旋锁时不做任何有用的工作，仅仅是等待。因此，只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。当临界区很大或有共享设备的时候，需要较长时间占用锁，使用自旋锁会降低系统的性能。


阻塞是指进程因等待某种东西而从运行态进入阻塞态，这个转换会使进程放弃当前持有的时间片，挂在阻塞队列中，直到被系统唤醒，期间不会占用cpu资源。。
而自旋锁，就相当于等待某个东西时进入一个死循环，不断地查询，会一直消耗cpu资源。所以自旋锁应用在持锁时间短的情况下使用，效率才会相比信号量高。


自旋锁和互斥锁区别:
自旋锁在等待获取锁的时候会一直循环检查该锁是否可用，如果可用则使用共享资源，如果不可用则继续循环进程，如果该进程的时间片用完，则切换到其他进程，当其他
进程时间片用完的时候，在切换到该等待自旋锁的时候，如果发现该锁还是不可用，则一直循环检测，直到时间片用完切换到其他进程，在自旋锁等待获取
共享资源的过程中会一直占用用CPU资源。
互斥锁在等待获取共享资源的时候，如果发现还不能获取到该锁，则该进程睡眠，立马让出CPU资源。立马进行进程间切换。

所以CPU自旋锁一般用在占用资源时间很短的情况下用，因为这样在进程的时间片呢，一般能自旋来判断出该锁可用，这样可以减少进程切换开销。
*/



/*
释放锁时需要Nginx模块通过ngx_atomic_cmp_set方法将原子变量lock值设为0。
    可以看到，ngx_spinlock方法是非常高效的自旋锁，它充分考虑了单处理器和多处理器的系统，对于持有锁时间非常短的场景很有效率


它有3个参数，其中，lock参数就是原子变量表达的锁，当lock值为0时表示锁是被释放的，而lock值不为0时则表示锁已经被某个进程持有了；
value参数表示希塑当锁没有被任何进程持有时（也就是lock值为0），把lock值设为value表示当前进程持有了锁；第三个参数spin表示在多处
理器系统内，当ngx_spinlock方法没有拿到锁时，当前进程在内核的一次调度中，该方法等待其他处理器释放锁的时间
*/
void 
//如果lock为0，表示可以获取锁，然后把lock置为value，如果lock不为0，则循环调度一会儿，再次检查，如果spin次循环还没有获取到锁，则让出CPU控制权
ngx_spinlock(ngx_atomic_t *lock, ngx_atomic_int_t value, ngx_uint_t spin)
{

#if (NGX_HAVE_ATOMIC_OPS)

    ngx_uint_t  i, n;

    //无法获取锁时进程的代码将一直在这个循环中执行
    for ( ;; ) {

        //lock为O时表示锁是没有被其他进程持有的，这时将lock值设为value参数表示当前进程持有了锁
        if (*lock == 0 && ngx_atomic_cmp_set(lock, 0, value)) {
            return;
        }

        //ngx_ncpu是处理器的个数，当它大于1时表示处于多处理器系统中
        if (ngx_ncpu > 1) {

             /*
                在多处理器下，更好的做法是当前进程不要立刻“让出”正在使用的CPU处理器，而是等待一段时间，看看其他处理器上的
                进程是否会释放锁，这会减少进程间切换的次数
                */
            for (n = 1; n < spin; n <<= 1) {
    
                /*
                    注意，随着等待的次数越来越多，实际去检查lock是否释放的频率会越来越小。为什么会这样呢？因为检查lock值更消耗CPU，
                    而执行ngx_cpu_pause对于CPU的能耗来说是很省电的
                    */            
                for (i = 0; i < n; i++) {
                    /*
                        gx_cpu_pause是在许多架构体系中专门为了自旋锁而提供的指令，它会告诉CPU现在处于自旋锁等待状悉，通常一些
                        CPU会将自己置于节能状态，降低功耗。注意，在执行ngx_cpu_pause后，当前进程没有“让出”正使用的处理器
                         */
                    ngx_cpu_pause();
                }

                //检查锁是否被释放了，如果lock值为0且释放了锁后，就把它的值设为value，当前进程持有锁成功并返回
                if (*lock == 0 && ngx_atomic_cmp_set(lock, 0, value)) {
                    return;
                }
            }
        }

        /*
          当前进程仍然处于可执行状态，但暂时“让出”处理器，使得处理器优先调度其他可执行状态的进程，这样，在进程被内核再次调度时，
          在for循环代码中可以期望其他进程释放锁。注意，不同的内核版本对于ngx_sched_yield系统调用的实现可能是不同的，但它们的目的都是暂时“让出”处理器
          */
        ngx_sched_yield();
    }

#else

#if (NGX_THREADS)

#error ngx_spinlock() or ngx_atomic_cmp_set() are not defined !

#endif

#endif

}

